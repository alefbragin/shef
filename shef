#!/bin/sh

##
# Build info variables
##

PROGRAM=shef
VERSION=0.0.0


##
# Usage of environment variables
##

STDIN_PATH="${SHEF_STDIN_PATH:-/dev/stdin}"
INCLUDE_PATH="${SHEF_INCLUDE_PATH:-/usr/local/lib/shef}"

SH_RUNNER="${SHEF_SH_RUNNER:-sh}"
STDIN_RUNNER="${SHEF_STDIN_RUNNER:-${SH_RUNNER}}"
STDIN_EXTENSION="${SHEF_STDIN_EXTENSION:-sh}"

init_runtime_path() {
	RUNTIME_PATH="${SHEF_RUNTIME_PATH:-/run/user/$(id -u)/shef}" || die "can't gets a user ID"
}

REMOVE_CLASHED_FIFO="${SHEF_REMOVE_CLASHED_FIFO:-0}"


##
# Utility variables
##

NL='
'

USAGE="Usage:
	${PROGRAM} --version | -V
	${PROGRAM} --help
	${PROGRAM} [-I PATH[:PATH]] [--] [TASK...]"

ERROR_CLOSE_FD="can't close file descriptor: %s"


##
# Utility functions
##

printf_() {
	printf "$@" || { echo "can't use printf" 1>&2; exit 1; }
}

die() {
	if [ $# -gt 0 ]; then
		format="$1" && shift
		printf_ "${PROGRAM}: ${format}\n" "$@" 1>&2
	fi

	exit 1
}

die_usage() {
	if [ $# -gt 0 ]; then
		die "${1}${NL}${USAGE}" "$2"
	else
		die "${USAGE}"
	fi
}

# Executes a command and redirects argument to it's STDIN.
#
# Arguments:
#   $1    Redirected argument.
#   $2... Command with it's arguments.
#
# Outputs:
#   STDIN|STDOUT Command's output.
#
# Never dies.
rarg() {
	arg="$1" && shift
	"$@" <<- EOF
		${arg}
	EOF
}

check_sanity() {
	LC_ALL=C rarg "$3" grep --extended-regexp --quiet "$1" \
		|| die "$2: '%s'" "$3"
}


##
# Shef's implementation functions
##

find_tasks() {
	for find_tasks__path; do
		if [ "${find_tasks__path}" = - ]; then
			printf_ '%s\n' "${STDIN_PATH}"
		else
			find_tasks__files="$(find "${find_tasks__path}" -type f -name '*.*')" \
				|| die "failed while find task files in the path: %s" "${find_tasks__path}"
			[ -n "${find_tasks__files}" ] \
				|| die "there are no task files in the path: %s" "${find_tasks__path}"
			LC_ALL=C rarg "${find_tasks__files}" sort || die "can't sort task files"
		fi
	done
}

# Search library by name and print it real path.
#
# If the library has already been found in a previous function call, the resulting
# real path will be empty. Note that found libraries are stored in the variable
# local to (sub)shell; this works as appropriate when this function is called
# in subshell associated with a runner.
#
# Arguments:
#   $1 Inclusion name with extension.
#
# Globals:
#   $INCLUDED_FILE Resulting real path or empty string.
#
# Dies if:
#   - bad library name;
#   - can't find library.
search_inclusion() {
	check_sanity '^[0-9a-z/-]+$' 'bad inclusion name' "$1"

	search_inclusion__included_var_name="search_inclusion__$(rarg "$1" tr '/-' 'S_')_included" \
		|| die "can't make variable name for inclusion indicator"
	eval "search_inclusion__included=\${${search_inclusion__included_var_name}}"

	if (( search_inclusion__included )); then
		INCLUDED_FILE=
		return 0
	fi

	search_inclusion_paths="${INCLUDE_PATH}"
	while [ -n "${search_inclusion_paths}" ]; do
		search_inclusion_path="${search_inclusion_paths%%:*}"
		INCLUDED_FILE="${search_inclusion_path}/$1"
		if [ -f "${INCLUDED_FILE}" ]; then
			eval "${search_inclusion__included_var_name}=1"
			return 0
		fi
		search_inclusion_paths="${search_inclusion_paths#${search_inclusion_path}}"
		search_inclusion_paths="${search_inclusion_paths#:}"
	done

	die "can't find inclusion: '$1'"
}

preprocess() {
	while IFS= read -r preprocess__line; do
		case "${preprocess__line}" in
			\#.*)
				preprocess__inc_name="${preprocess__line#\#.}"
				# Left trim
				preprocess__inc_name="${preprocess__inc_name#${preprocess__inc_name%%[![:blank:]]*}}"
				# Right trim
				preprocess__inc_name="${preprocess__inc_name%${preprocess__inc_name##*[![:blank:]]}}"

				search_inclusion "${preprocess__inc_name}.$1"

				if [ -d "${INCLUDED_FILE}" ]; then
					preprocess__inc_files="$(find "${INCLUDED_FILE}" -type f)" \
						|| die "failed while find files in directory for inclusion: %s" "${INCLUDED_FILE}"
					[ -n "${preprocess__inc_files}" ] \
						|| die "there are no task files in the path: %s" "${INCLUDED_FILE}"

					while IFS= read -r preprocess__inc_file; do
						# exec 7<&0 0<&3 || die "can't reassign file descriptors: 0, 7"
						preprocess < "${preprocess__inc_file}"
						# exec 0<&7 7<&- || die "can't reassign file descriptor and close it: 0, 7"
					done <<- EOF || die "can't output tasks content to the pipe"
						${preprocess__inc_files}
					EOF

				elif [ -n "${INCLUDE_PATH}" ]
					preprocess < "${INCLUDED_FILE}"
				fi
			;;
			\#*) continue ;;
			*) printf_ '%s\n' "${preprocess__line}" ;;
		esac
	done
	cat
}

# Run task files by the runner command.
#
# Arguments:
#   $1 Runner command.
#   $2 List of task files, each one on a separate line.
#
# Globals:
#   $RUNTIME_PATH        Path to create temporary FIFO.
#   $REMOVE_CLASHED_FIFO If trueish, remove file that clashed with temporary FIFO file name.
#   &3                   File descriptor. Expect to be assigned to STDIN.
#
# Dies if:
#   - can't create runtime path;
#   - can't create, open, remove FIFO;
#   - can't reassign, close file descriptors;
#   - task preprocessing fails;
#   - runner command error.
run() {
	if [ ! -d "${RUNTIME_PATH}" ]; then
		mkdir --parent "${RUNTIME_PATH}" \
			|| die "can't create runtime path: '${RUNTIME_PATH}'"
	fi

	run__fifo="${RUNTIME_PATH}/$$.fifo"

	if (( REMOVE_CLASHED_FIFO )); then
		rm -f "${run__fifo}" || die "can't remove clashed FIFO: %s" "${run__fifo}"
	fi

	mkfifo "${run__fifo}" || die "can't create temporary FIFO: %s" "${run__fifo}"
	exec 5<>"${run__fifo}" 6<"${run__fifo}" \
		|| die "can't open file descriptors for FIFO: %s" "${run__fifo}"
	rm "${run__fifo}" || die "can't remove FIFO file: %s" "${run__fifo}"

	{
		while IFS= read -r run__file; do
			exec 4<&0 0<&3 || die "can't reassign file descriptors: 0, 3"

			# Sanity check of dot presence in file name isn't needed
			# becouse of '*.*' pattern in the find command in find_tasks function.
			preprocess "${run__file##*.}" < "${run__file}"

			exec 0<&4 4<&- || die "can't reassign file descriptor and close it: 0, 4"
		done <<- EOF >&5 || die "can't output tasks content to the pipe"
			$2
		EOF
	} &

	exec 5>&- || die "${ERROR_CLOSE_FD}" 5

	$1 <&6 || die "can't run task file with runner"
	exec 6<&- || die "${ERROR_CLOSE_FD}" 6

	wait $! || die 'subprocess for task preprocessing fails'
}

set_file_runner() {
	if [ "$1" = "${STDIN_PATH}" ]; then
		[ -n "${STDIN_RUNNER}" ] \
			|| die 'no runner specified for the task from STDIN'
		FILE_RUNNER="${STDIN_RUNNER}"
	else
		set_file_runner__name="${1##*/}"
		set_file_runner__name="$(
			rarg "${set_file_runner__name#*.}" tr '.[:lower:]' '_[:upper:]'
		)" || die "can't process file's suffix"

		check_sanity '^[0-9a-z]+$' 'bad runner name' "${set_file_runner__name}"

		set_file_runner__env_name="SHEF_${set_file_runner__name}_RUNNER"

		eval "FILE_RUNNER=\${${set_file_runner__env_name}}" \
			|| die "can't assign FILE_RUNNER variable from: '${set_file_runner__env_name}'"

		[ -n "${FILE_RUNNER}" ] \
			|| die "no runner specified for the task: %s in %s" "$1" "${set_file_runner__env_name}"
	fi
}


##
# Commands
##

cmd_version() {
	[ $# -eq 0 ] || die_usage "extra argument: '%s'" "$1"
	echo "shef version ${VERSION}"
}

cmd_help() {
	echo "${USAGE}"
}

cmd() {
	while getopts ':I:' cmd__option; do case "${cmd__option}" in
		I)
			check_sanity '^[^:]+(:[^:]+)*$' 'incorrect include paths format' "${OPTARG}"
			INCLUDE_PATH="${OPTARG}:${INCLUDE_PATH}"
		;;
		\?) die_usage 'invalid option: -%s' "${OPTARG}" ;;
		:) die_usage 'option -%s requires an argument' "${OPTARG}" ;;
	esac done
	shift $(( OPTIND-1 ))

	cmd__task_files="$(find_task "${@:--}")" || die

	init_runtime_path

	exec 3<&0 || die "can't open file descriptor 3 for: 0"
	if IFS= read -r cmd__task_file; then
		set_file_runner "${cmd__task_file}"
		cmd__files_bunch="${cmd__task_file}"

		while IFS= read -r cmd__task_file; do
			cmd__prev_file_runner="${FILE_RUNNER}"
			set_file_runner "${cmd__task_file}"

			if [ "${cmd__prev_file_runner}" = "${FILE_RUNNER}" ]; then
				cmd__files_bunch="${cmd__files_bunch}${NL}${cmd__task_file}"
			else
				run "${cmd__prev_file_runner}" "${cmd__files_bunch}"
				cmd__files_bunch="${cmd__task_file}"
			fi
		done

		run "${FILE_RUNNER}" "${cmd__files_bunch}"
	fi <<- EOF || die "can't process task files"
		${cmd__task_files}
	EOF
	exec 3<&- || die "${ERROR_CLOSE_FD}" 3
}


##
# Entry point
##

case "$1" in
	--version|-V) shift; cmd_version "$@" ;;
	--help) cmd_help ;;
	*) cmd "$@" ;;
esac
