#!/bin/sh

PROGRAM=shef
VERSION=0.0.0
INCLUDE_PATH="${SHEF_INCLUDE_PATH:-/usr/lib/shef}"

NL='
'

ERROR_TASK_RUN='cannot run task file'
ERROR_VARIABLE_EMPTY="required variable '%s' is empty"

# Ensure that `printf` program exists
printf '' || exit 1

print() {
  printf '%s' "$1"
}

println() {
  printf '%s\n' "$1"
}

usage_print() {
  indent="$(print "${PROGRAM}" | tr '[:print:]' ' ')" || exit 1
  print "Usage:
    ${PROGRAM} --version | -V
    ${PROGRAM} [--include-path=<path> | -I <path>]
    ${indent} [--default-environment=l[ocal]|t[arget] | -e l[ocal]|t[arget]]
    ${indent} [--] [<task>...]
"
}

die() {
  if [ "$1" = --usage ]; then
    option="$1" && shift
  fi

  if [ $# -gt 0 ]; then
    format="$1" && shift
    printf "${PROGRAM}: ${format}\n" "$@" 1>&2

    if [ "${option}" = --usage ]; then
      println 1>&2
    fi
  fi

  if [ "${option}" = --usage ]; then
    usage_print 1>&2
  fi

  exit 1
}

fnmatch() {
  case "$2" in
    $1) return 0 ;;
    *) return 1 ;;
  esac
}

file_has_option() {
  fnmatch "*.$2.*" "$1"
}

task_find() {
  for task; do
    if [ "${task}" = - ]; then
      println -
    else
      find_result="$(find "${task}" -type f \( -name '*.sh' -o -name '*.inc' \) )" \
        || die "cannot find for the task path: '${task}'"
      [ -n "${find_result}" ] || die "there are no task files in the path: '${task_path}'"
      print "${find_result}" | LC_ALL=C sort || die
    fi
  done
}

search_library() {
  print "$1" | LC_ALL=C grep '^[0-9a-z-]\+$' || die "bad library name: '$1'"

  hash_key="$(print "shef_include_hash/$1" | tr '/' 'S')" \
    || die 'cannot make hash key for the library'
  eval "hash_value=\"\${${hash_key}}\""

  if [ -n "${hash_value}" ]; then
    println "${hash_value}"
    return 0
  fi

  print "${shef_include_path}" | while IFS=: read -r path; do
    lib_path="${path}/$1.sh"
    if [ -f "${lib_path}" ]; then
      eval "${hash_key}=\"\${lib_path}\""
      println "${lib_path}"
      return 0
    fi
  done || die

  die "cannot find library: '$1'"
}

mktemp_task() {
  shef_task_file="$(mktemp --tmpdir shef.XXXXXXXXXX.sh)" \
    || die 'cannot create temp file for task script'
  trap "shred ${shef_task_file}; rm -f ${shef_task_file}" EXIT
}

write_task() {
  cat "$1" >> "${shef_task_file}" || die 'cannot write to temp task file'
}

truncate_task() {
  shred "${shef_task_file}" || die 'cannot shred temp task file'
  > "${shef_task_file}" || die 'cannot truncate temp task file'
}

run_env() {
  case "$1" in
    local)
      sh < "${shef_task_file}" || die "${ERROR_TASK_RUN}"
    ;;
    target)
      [ -n "${SHEF_TARGET_HOST}" ] || die "${ERROR_VARIABLE_EMPTY}" SHEF_TARGET_HOST
      [ -n "${SHEF_TARGET_USER}" ] || die "${ERROR_VARIABLE_EMPTY}" SHEF_TARGET_USER

      ssh -T "${SHEF_TARGET_USER}@${SHEF_TARGET_HOST}" -- sh < "${shef_task_file}" \
        || die "${ERROR_TASK_RUN}"
    ;;
  esac
}

parse_env() {
  case "$1" in
    local|l) print local ;;
    target|t) print target ;;
    *) die --usage "cannot parse environment '$1'"
  esac
}

cmd_version_print() {
  [ $# -eq 0 ] || die --usage "extra argument: '%s'" "$@"
  printf 'shef version %s\n' "${VERSION}"
}

cmd_shef() {
  options="$(getopt \
    --options I:e: \
    --longoptions include-path:,default-environment: \
    -- "$@")" || die --usage

  eval set -- "${options}"

  shef_include_path="${INCLUDE_PATH}"

  while :; do case "$1" in
    --include-path|-I)
      shef_include_path="$2:${shef_include_path}"
      shift 2
    ;;
    --default-environment|-e)
      default_env="$(parse_env "$2")" || die
      shift 2
    ;;
    --)
      shift
      break
    ;;
  esac done

  files="$(task_find "${@:--}")" || die

  mktemp_task

  prev_env=
  print "${files}" | while IFS= read -r file; do
    if file_has_option "${file}" local; then
      ! file_has_option "${file}" target \
        || die "task cannot be 'local' and 'target' at same time: '${file}'"
      env=local
    elif file_has_option "${file}" target; then
      env=target
    else
      [ -n "${default_env}" ] \
        || die "no environment specified for the task '${file}' and there are no default one"
      env="${default_env}"
    fi

    if [ "${env}" != "${prev_env}" -a -n "${prev_env}" ]; then
      run_env "${prev_env}"
      truncate_task
    fi

    if fnmatch '*.inc' "${file}"; then
      while IFS= read -r lib; do
        lib_path="$(search_library "${lib}")" || die
        write_task "${lib_path}"
      done < "${file}"
    else
      write_task "${file}"
    fi

    prev_env="${env}"
  done || die

  run_env "${env}"
  truncate_task
}

case "$1" in
  --version|-V) shift; cmd_version_print "$@" ;;
  --help) usage_print ;;
  *) cmd_shef "$@" ;;
esac
