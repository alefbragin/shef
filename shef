#!/bin/sh

PROGRAM=shef
VERSION=0.0.0

SHEF_STDIN_PATH="${SHEF_STDIN_PATH:-/dev/stdin}"
SHEF_RUNTIME_PATH="${SHEF_RUNTIME_PATH:-/run/user/$(id -u)/shef}" || exit 1
SHEF_INCLUDE_PATH="${SHEF_INCLUDE_PATH:-/usr/local/lib/shef}"

SHEF_LOCAL_RUNNER="${SHEF_LOCAL_RUNNER:-sh}"
SHEF_REMOTE_RUNNER="${SHEF_REMOTE_RUNNER:-ssh -T ${SHEF_REMOTE_USER}@${SHEF_REMOTE_HOST} -- sh}"

NL='
'

ERROR_CLOSE_FD='cannot close file descriptor: %s'

stdin_arg() {
	arg="$1" && shift
	"$@" <<- EOF
		${arg}
	EOF
}

print_usage() {
	indent="$(stdin_arg "${PROGRAM}" tr '[:print:]' ' ')" \
		|| die 'cannot make indentation for synopsis'
	cat <<- EOF || die 'cannot print usage'
		Usage:
		  ${PROGRAM} --version | -V
		  ${PROGRAM} --help
		  ${PROGRAM} [--include-path=<[prefix=]path> | -I <[prefix=]path>]
		  ${indent} [--stdin-runner=<name> | -r <name>]
		  ${indent} [--remove-clashed-fifo]
		  ${indent} [--] [<task>...]
	EOF
}

die() {
	if [ "$1" = --usage ]; then
		show_usage=yes && shift
	fi

	if [ $# -gt 0 ]; then
		format="$1" && shift
		printf "${PROGRAM}: ${format}\n" "$@" 1>&2 || exit 1
	fi

	if [ "${show_usage}" = yes ]; then
		echo 1>&2
		print_usage 1>&2
	fi

	exit 1
}

check_sanity() {
	LC_ALL=C stdin_arg "$3" grep --extended-regexp --quiet "$1" \
		|| die "$2: '%s'" "$3"
}

find_task() {
	for task; do
		if [ "${task}" = - ]; then
			printf '%s\n' "${SHEF_STDIN_PATH}" || die 'cannot print STDIN path'
		else
			task_files="$(find "${task}" -type f -name '*.sh')" \
				|| die "cannot find task files for the path: '${task}'"
			[ -n "${task_files}" ] || die "there are no task files in the path: '${task_path}'"
			LC_ALL=C stdin_arg "${task_files}" sort || die 'cannot sort task files'
		fi
	done
}

##
# Search library by name and print it real path.
#
# If the library has already been found in a previous function call, the resulting
# real path will be empty. Note that found libraries are stored in the variable
# local to (sub)shell; this works as appropriate when this function is called
# in subshell associated with a runner.
#
# Arguments:
#	$1 Library name
#
# Globals:
#	$shef_library_path Resulting real path or empty string
#
# Dies if:
#	- bad library name
#	- cannot find library
##
search_library() {
	check_sanity '^[0-9a-z/-]+$' 'bad library name' "$1"

	hash_key="$(stdin_arg "shef_library_hashC$1" tr '/-' 'S_')" \
		|| die 'cannot make hash key for the library'
	eval "hash_value=\"\${${hash_key}}\"" \
		|| die "cannot take value for the key: '${hash_key}'"

	if [ "${hash_value}" = found ]; then
		shef_library_path=
		return 0
	fi

	IFS=:
	for path in "${shef_include_path}"; do
		shef_library_path="${path}/$1.sh"
		if [ -f "${shef_library_path}" ]; then
			eval "${hash_key}=found" \
				|| die "cannot assign value for the key: '${hash_key}'"
			return 0
		fi
	done

	die "cannot find library: '$1'"
}

include_libraries() {
	while IFS= read -r line; do
		printf '%s\n' "${line}" || die 'cannot print the line to the task'
		case "${line#${line%%[![:blank:]]*}}" in
			\#.*)
				lib="$(stdin_arg "${line}" sed 's/\(^[[:blank:]]*#\.[[:blank:]]*\|[[:blank:]]*$\)//g')" \
					|| die "cannot extract library name from line: '${line}'"

				search_library "${lib}"
				if [ -n "${shef_library_path}" ]; then
					include_libraries < "${shef_library_path}"
				fi
			;;
			\#*|'') continue ;;
			*) break ;;
		esac
	done
	cat
}

##
# Run task files by the runner.
#
# Arguments:
#	$1 Runner name.
#	$2 List of task files, each one on a separate line.
#
# Globals:
#	$SHEF_RUNTIME_PATH Path to create temporary FIFO.
#	$SHEF_*_RUNNER Command for substituted (instead of '*') runner.
#	               E.g. 'SHEF_LOCAL_RUNNER'.
#	$shef_remove_clashed_fifo If 'yes' remove file that clashed with temporary
#	                          FIFO file name.
#	&3 Expect file descriptor to be assigned to STDIN.
#
# Dies if:
#	- no runner command setup for the runner name
#	- subprocess for task preprocession fails
#	- runner command error
##
run() {
	runner_uppercase_name="$(stdin_arg "$1" tr '[:lower:]' '[:upper:]')" \
		|| die 'cannot convert runner name to uppercase'

	eval "runner=\"\${SHEF_${runner_uppercase_name}_RUNNER}\"" \
		|| die "cannot assign to the runner variable for: '$1'"
	[ -n "${runner}" ] || die "no runner command setup for this name: '$1'"

	if [ ! -d "${SHEF_RUNTIME_PATH}" ]; then
		mkdir --parent "${SHEF_RUNTIME_PATH}" \
			|| die "cannot create runtime path: '${SHEF_RUNTIME_PATH}'"
	fi

	fifo="${SHEF_RUNTIME_PATH}/$$.$1.fifo"

	if [ "${shef_remove_clashed_fifo}" = yes ]; then
		rm -f "${fifo}" || die "cannot remove clashed FIFO: '${fifo}'"
	fi

	mkfifo "${fifo}" || die "cannot create temporary FIFO: '${fifo}'"
	exec 5<>"${fifo}" 6<"${fifo}" \
		|| die "cannot open file descriptors for FIFO: '${fifo}'"
	rm "${fifo}" || die "cannot remove clashed file: '${fifo}'"

	{
		while IFS= read -r run_file; do
			exec 4<&0 0<&3 || die 'cannot reassign file descriptors: 0, 3'
			include_libraries < "${run_file}"
			exec 0<&4 4<&- || die 'cannot reassign file descriptor 4 and close its'
		done <<- EOF >&5 || die 'cannot output tasks content to the pipe'
			$2
		EOF
	} &

	exec 5>&- || die "${ERROR_CLOSE_FD}" 5

	${runner} <&6 || die "cannot run task file with runner: '${runner}'"
	exec 6<&- || die "${ERROR_CLOSE_FD}" 6

	wait $! || die 'subprocess for task preprocession fails'
}

file_runner() {
	if [ "$1" = "${SHEF_STDIN_PATH}" ]; then
		[ -n "${shef_stdin_runner}" ] \
			|| die 'no runner specified for the task from STDIN'
		shef_runner="${shef_stdin_runner}"
	else
		shef_runner="${1%.sh}"
		shef_runner="${shef_runner##*[/.]}"
	fi
}

cmd_print_version() {
	[ $# -eq 0 ] || die --usage "extra argument: '%s'" "$@"
	printf 'shef version %s\n' "${VERSION}" || die 'cannot print Shef version'
}

cmd_shef() {
	options="$(getopt \
		--options I:r: \
		--longoptions include-path:,stdin-runner: \
		--longoptions remove-clashed-fifo,no-remove-clashed-fifo \
		-- "$@")" || die --usage

	eval set -- "${options}"

	shef_include_path="${SHEF_INCLUDE_PATH}"

	while :; do case "$1" in
		--include-path|-I)
			shef_include_path="$2:${shef_include_path}" && shift 2
		;;
		--stdin-runner|-r)
			check_sanity '^[0-9a-z-]+$' 'bad runner name' "$2"
			shef_stdin_runner="$2" && shift 2
		;;
		--remove-clashed-fifo)
			shef_remove_clashed_fifo=yes && shift
		;;
		--no-remove-clashed-fifo)
			shef_remove_clashed_fifo=no && shift
		;;
		--)
			shift && break
		;;
	esac done

	task_files="$(find_task "${@:--}")" || die

	exec 3<&0 || die 'cannot open file descriptor 3 for: 0'
	if IFS= read -r task_file; then
		file_runner "${task_file}"
		run_files="${task_file}"

		while IFS= read -r task_file; do
			prev_runner="${shef_runner}"
			file_runner "${task_file}"

			if [ "${prev_runner}" = "${shef_runner}" ]; then
				run_files="${run_files}${NL}${task_file}"
			else
				run "${prev_runner}" "${run_files}"
				run_files="${task_file}"
			fi
		done

		run "${shef_runner}" "${run_files}"
	fi <<- EOF || die 'cannot process task files'
		${task_files}
	EOF
	exec 3<&- || die "${ERROR_CLOSE_FD}" 3
}

case "$1" in
	--version|-V) shift; cmd_print_version "$@" ;;
	--help) print_usage ;;
	*) cmd_shef "$@" ;;
esac
