#!/bin/sh

##
# Build info variables
##

PROGRAM=shef
VERSION=0.0.0

# Just amount of spaces that equals the length of the program's name.
# It's used for pretty print usage info.
PROGRAM_SPACES='    '


##
# Usage of environment variables
##

STDIN_PATH="${SHEF_STDIN_PATH:-/dev/stdin}"
INCLUDE_PATH="${SHEF_INCLUDE_PATH:-/usr/local/lib/shef}"

SH_RUNNER="${SHEF_SH_RUNNER:-sh}"
STDIN_RUNNER="${SHEF_STDIN_RUNNER:-${SH_RUNNER}}"

init_runtime_path() {
	RUNTIME_PATH="${SHEF_RUNTIME_PATH:-/run/user/$(id -u)/shef}" || die "can't gets a user ID"
}

REMOVE_CLASHED_FIFO="${SHEF_REMOVE_CLASHED_FIFO:-0}"


##
# Utility variables
##

NL='
'

USAGE="Usage:
	${PROGRAM} --version | -V
	${PROGRAM} --help
	${PROGRAM} [--include-path=PATH[:PATH] | -I PATH[:PATH]]
	${PROGRAM_SPACES} [--remove-clashed-fifo | --no-remove-clashed-fifo]
	${PROGRAM_SPACES} [--] [TASK...]"

ERROR_CLOSE_FD="can't close file descriptor: %s"


##
# Utility functions
##

printf_() {
	printf "$@" || { echo "can't use printf" 1>&2; exit 1; }
}

die() {
	if [ $# -gt 0 ]; then
		format="$1" && shift
		printf_ "${PROGRAM}: ${format}\n" "$@" 1>&2
	fi

	exit 1
}

die_usage() {
	if [ $# -gt 0 ]; then
		die "${1}${NL}${USAGE}" "$2"
	else
		die "${USAGE}"
	fi
}

# Executes a command and redirects argument to it's STDIN.
#
# Arguments:
#   $1    Redirected argument.
#   $2... Command with it's arguments.
#
# Outputs:
#   STDIN|STDOUT Command's output.
#
# Never dies.
rarg() {
	arg="$1" && shift
	"$@" <<- EOF
		${arg}
	EOF
}

check_sanity() {
	LC_ALL=C rarg "$3" grep --extended-regexp --quiet "$1" \
		|| die "$2: '%s'" "$3"
}


##
# Shef's implementation functions
##

find_tasks() {
	for find_tasks__path; do
		if [ "${find_tasks__path}" = - ]; then
			printf_ '%s\n' "${STDIN_PATH}"
		else
			find_tasks__files="$(find "${find_tasks__path}" -type f -name '*.*')" \
				|| die "task files for the path are not found: %s" "${find_tasks__path}"
			[ -n "${find_tasks__files}" ] \
				|| die "there are no task files in the path: %s" "${find_tasks__path}"
			LC_ALL=C rarg "${find_tasks__files}" sort || die "can't sort task files"
		fi
	done
}

# Search library by name and print it real path.
#
# If the library has already been found in a previous function call, the resulting
# real path will be empty. Note that found libraries are stored in the variable
# local to (sub)shell; this works as appropriate when this function is called
# in subshell associated with a runner.
#
# Arguments:
#   $1 Library name.
#
# Globals:
#   $shef_library_path Resulting real path or empty string.
#
# Dies if:
#   - bad library name;
#   - can't find library.
search_library() {
	check_sanity '^[0-9a-z/-]+$' 'bad library name' "$1"

	hash_key="$(rarg "shef_library_hashC$1" tr '/-' 'S_')" \
		|| die "can't make hash key for the library"
	eval "hash_value=\${${hash_key}}" \
		|| die "can't take value for the key: '${hash_key}'"

	if [ "${hash_value}" = found ]; then
		shef_library_path=
		return 0
	fi

	include_paths="${shef_include_path}"
	while [ -n "${include_paths}" ]; do
		case "${include_paths}" in
			*:*)
				prefix_path="${include_paths%%:*}"
				include_paths="${include_paths#*:}"
			;;
			*)
				prefix_path="${include_paths}"
				include_paths=
			;;
		esac
		prefix="${prefix_path%%=*}"
		shef_library_path="${prefix_path#${prefix}=}/${1#${prefix}}.sh"
		if [ -f "${shef_library_path}" ]; then
			eval "${hash_key}=found" \
				|| die "can't assign value for the key: '${hash_key}'"
			return 0
		fi
	done

	die "can't find library: '$1'"
}

include_libraries() {
	while IFS= read -r line; do
		printf_ '%s\n' "${line}"
		case "${line#${line%%[![:blank:]]*}}" in
			\#.*)
				lib="$(rarg "${line}" sed 's/\(^[[:blank:]]*#\.[[:blank:]]*\|[[:blank:]]*$\)//g')" \
					|| die "can't extract library name from line: '${line}'"

				search_library "${lib}"
				if [ -n "${shef_library_path}" ]; then
					include_libraries < "${shef_library_path}"
				fi
			;;
			\#*|'') continue ;;
			*) break ;;
		esac
	done
	cat
}

# Run task files by the runner command.
#
# Arguments:
#   $1 Runner command
#   $2 List of task files, each one on a separate line.
#
# Globals:
#   $RUNTIME_PATH        Path to create temporary FIFO.
#   $REMOVE_CLASHED_FIFO If trueish, remove file that clashed with temporary FIFO file name.
#   &3                   File descriptor. Expect to be assigned to STDIN.
#
# Dies if:
#   - can't create runtime path;
#   - can't create, open, remove FIFO;
#   - can't reassign, close file descriptors;
#   - task preprocessing fails;
#   - runner command error.
run() {
	if [ ! -d "${RUNTIME_PATH}" ]; then
		mkdir --parent "${RUNTIME_PATH}" \
			|| die "can't create runtime path: '${RUNTIME_PATH}'"
	fi

	run__fifo="${RUNTIME_PATH}/$$.fifo"

	if (( REMOVE_CLASHED_FIFO )); then
		rm -f "${run__fifo}" || die "can't remove clashed FIFO: %s" "${run__fifo}"
	fi

	mkfifo "${run__fifo}" || die "can't create temporary FIFO: %s" "${run__fifo}"
	exec 5<>"${run__fifo}" 6<"${run__fifo}" \
		|| die "can't open file descriptors for FIFO: %s" "${run__fifo}"
	rm "${run__fifo}" || die "can't remove FIFO file: %s" "${run__fifo}"

	{
		while IFS= read -r run__file; do
			exec 4<&0 0<&3 || die "can't reassign file descriptors: 0, 3"
			include_libraries < "${run__file}"
			exec 0<&4 4<&- || die "can't reassign file descriptor and close its: 4"
		done <<- EOF >&5 || die "can't output tasks content to the pipe"
			$2
		EOF
	} &

	exec 5>&- || die "${ERROR_CLOSE_FD}" 5

	$1 <&6 || die "can't run task file with runner"
	exec 6<&- || die "${ERROR_CLOSE_FD}" 6

	wait $! || die 'subprocess for task preprocessing fails'
}

check_runner_name_sanity() {
	check_sanity '^[0-9a-z]+$' 'bad runner name' "$2"
}

set_file_runner() {
	if [ "$1" = "${SHEF_STDIN_PATH}" ]; then
		[ -n "${SHEF_STDIN_RUNNER}" ] \
			|| die 'no runner specified for the task from STDIN'
		FILE_RUNNER="${SHEF_STDIN_RUNNER}"
	else
		set_file_runner__name="${1##*/}"
		set_file_runner__name="$(
			rarg "${set_file_runner__name#*.}" tr '.[:lower:]' '_[:upper:]'
		)" || die "can't process file's suffix"

		check_runner_name_sanity "${set_file_runner__name}"

		set_file_runner__env_name="SHEF_${set_file_runner__name}_RUNNER"

		eval "FILE_RUNNER=\${${set_file_runner__env_name}}" \
			|| die "can't assign FILE_RUNNER variable from: '${set_file_runner__env_name}'"

		[ -n "${FILE_RUNNER}" ] \
			|| die "no runner specified for the task: %s in %s" "$1" "${set_file_runner__env_name}"
	fi
}

check_include_path_sanity() {
	check_sanity '^[^:]+(:[^:]+)*$' 'incorrect include paths format' "$1"
}


##
# Commands
##

cmd_version() {
	[ $# -eq 0 ] || die_usage "extra argument: '%s'" "$1"
	echo "shef version ${VERSION}"
}

cmd_help() {
	echo "${USAGE}"
}

cmd() {
	cmd__options="$(getopt \
		--options I: \
		--longoptions include-path: \
		-- "$@")" || die_usage

	eval set -- "${cmd__options}"

	check_include_path_sanity "${INCLUDE_PATH}"

	while :; do case "$1" in
		--include-path|-I)
			check_include_path_sanity "$2"
			INCLUDE_PATH="$2:${INCLUDE_PATH}" && shift 2
		;;
		--)
			shift && break
		;;
	esac done

	cmd__task_files="$(find_task "${@:--}")" || die

	init_runtime_path

	exec 3<&0 || die "can't open file descriptor 3 for: 0"
	if IFS= read -r cmd__task_file; then
		set_file_runner "${cmd__task_file}"
		cmd__files_bunch="${cmd__task_file}"

		while IFS= read -r cmd__task_file; do
			cmd__prev_file_runner="${FILE_RUNNER}"
			set_file_runner "${cmd__task_file}"

			if [ "${cmd__prev_file_runner}" = "${FILE_RUNNER}" ]; then
				cmd__files_bunch="${cmd__files_bunch}${NL}${cmd__task_file}"
			else
				run "${cmd__prev_file_runner}" "${cmd__files_bunch}"
				cmd__files_bunch="${cmd__task_file}"
			fi
		done

		run "${FILE_RUNNER}" "${cmd__files_bunch}"
	fi <<- EOF || die "can't process task files"
		${cmd__files_bunch}
	EOF
	exec 3<&- || die "${ERROR_CLOSE_FD}" 3
}


##
# Entry point
##

case "$1" in
	--version|-V) shift; cmd_version "$@" ;;
	--help) cmd_help ;;
	*) cmd "$@" ;;
esac
