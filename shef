#!/bin/sh

PROGRAM=shef
VERSION=0.0.0
INCLUDE_PATH="${SHEF_INCLUDE_PATH:-/usr/lib/shef}"

TASK_RUNNER_LOCAL='sh'
TASK_RUNNER_TARGET='ssh -T "${target_user}@${target_host}" -- sh'

NL='
'

print() {
  printf '%s' "$1"
}

println() {
  printf '%s\n' "$1"
}

usage_print() {
  indent="$(print "${PROGRAM}" | tr '[:print:]' ' ')"
  print "Usage:
    ${PROGRAM} --version | -V
    ${PROGRAM} [--prelude=<script> | -p <script>]
    ${indent} [--prelude-local=<script> | -l <script>]
    ${indent} [--prelude-target=<script> | -t <script>]
    ${indent} [--builtin-prelude] [--no-builtin-prelude]
    ${indent} [--include-path=<path> | -I <path>]
    ${indent} [--builtin-include-path] [--no-builtin-include-path]
    ${indent} [--variable=<name>=<value> | -v <name>=<value>]
    ${indent} [--default-environment=l[ocal]|t[arget] | -e l[ocal]|t[arget]]
    ${indent} [--] [<task>...]
"
}

die() {
  if [ "$1" = --usage ]; then
    option="$1" && shift
  fi

  if [ $# -gt 0 ]; then
    format="$1" && shift
    printf "${PROGRAM}: ${format}\n" "$@" 1>&2

    if [ "${option}" = --usage ]; then
      println 1>&2
    fi
  fi

  if [ "${option}" = --usage ]; then
    usage_print 1>&2
  fi

  exit 1
}

cmd_version_print() {
  [ $# -eq 0 ] || die --usage "extra argument: '%s'" "$@"
  printf 'shef version %s\n' "${VERSION}"
}

file_has_option() {
  print "$1" | grep --quiet "\.$2\."
}

task_find() {
  for task; do
    if [ "${task}" = - ]; then
      println -
    else
      find_result="$(find "${task}" -type f \( -name '*.sh' -o -name '*.inc' \) )" \
        || die "cannot find for the task path: '${task}'"
      [ -n "${find_result}" ] || die "there are no task files in the path: '${task_path}'"
      print "${find_result}" | sort
    fi
  done
}

run_task() {
  case "$2" in
    local) task_runner="${TASK_RUNNER_LOCAL}" ;;
    target) task_runner="${TASK_RUNNER_TARGET}" ;;
  esac

  printf "run with '%s':\n" "${task_runner}"
  print "$1" | sed 's/^/\t/'
}

parse_env() {
  case "$1" in
    local|l) print local ;;
    target|t) print target ;;
    *) die --usage "cannot parse environment '$1'"
  esac
}

# TODO: 010-deploy.local.include
cmd_shef() {
  options="$(getopt \
    --options p:l:t:I:v:e: \
    --longoptions prelude:,prelude-local:,prelude-target: \
    --longoptions builtin-prelude,no-builtin-prelude \
    --longoptions include-path: \
    --longoptions builtin-include-path,no-builtin-include-path \
    -- "$@")" || die --usage 'cannot parse options'

  eval set -- "${options}"

  while :; do case "$1" in
    -p|--prelude)
      die "not implemented yet"
      shift 2
    ;;
    --prelude-local|-l)
      die "not implemented yet"
      shift 2
    ;;
    --prelude-target|-t)
      die "not implemented yet"
      shift 2
    ;;
    --builtin-prelude)
      die "not implemented yet"
      shift
    ;;
    --no-builtin-prelude)
      die "not implemented yet"
      shift
    ;;
    --include-path|-I)
      die "not implemented yet"
      shift 2
    ;;
    --builtin-include-path)
      die "not implemented yet"
      shift
    ;;
    --no-builtin-include-path)
      die "not implemented yet"
      shift
    ;;
    --variable|-v)
      die "not implemented yet"
      shift 2
    ;;
    --default-environment|-e)
      default_env="$(parse_env "$2")" || die
      shift 2
    ;;
    --)
      shift
      break
    ;;
  esac done

  task_files="$(task_find "${@:--}")" || die

  env_files=
  prev_env=

  while IFS= read -r file; do
    if file_has_option "${file}" local; then
      ! file_has_option "${file}" target \
        || die "task cannot be 'local' and 'target' at same time: '${file}'"
      env=local
    elif file_has_option "${file}" target; then
      env=target
    else
      [ -n "${default_env}" ] \
        || die "no environment specified for the task '${file}' and there are no default one"
      env="${default_env}"
    fi

    if [ "${env}" = "${prev_env}" -o "${prev_env}" = '' ]; then
      env_files="${env_files}${file}${NL}"
    else
      run_task "${env_files}" "${prev_env}"
      env_files="${file}${NL}"
    fi

    prev_env="${env}"
  done << EOF
${task_files}
EOF

  run_task "${env_files}" "${env}"
}

case "$1" in
  --version|-V) shift; cmd_version_print "$@" ;;
  --help) usage_print ;;
  *) cmd_shef "$@" ;;
esac
