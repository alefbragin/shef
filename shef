#!/bin/sh

PROGRAM=shef
VERSION=0.0.0
STDIN_PATH=/dev/stdin
INCLUDE_PATH="${SHEF_INCLUDE_PATH:-/usr/local/lib/shef}"

ERROR_TASK_RUN='cannot run task file'
ERROR_VARIABLE_EMPTY="required variable '%s' is empty"

# Ensure that `printf` program exists
printf '' || exit 1

print() {
  printf '%s' "$1"
}

println() {
  printf '%s\n' "$1"
}

usage_print() {
  indent="$(print "${PROGRAM}" | tr '[:print:]' ' ')" || exit 1
  print "Usage:
    ${PROGRAM} --version | -V
    ${PROGRAM} [--include-path=<path> | -I <path>]
    ${indent} [--environment=l[ocal]|t[arget] | -e l[ocal]|t[arget]]
    ${indent} [--] [<task>...]
"
}

die() {
  if [ "$1" = --usage ]; then
    option="$1" && shift
  fi

  if [ $# -gt 0 ]; then
    format="$1" && shift
    printf "${PROGRAM}: ${format}\n" "$@" 1>&2

    if [ "${option}" = --usage ]; then
      println 1>&2
    fi
  fi

  if [ "${option}" = --usage ]; then
    usage_print 1>&2
  fi

  exit 1
}

fnmatch() {
  case "$2" in
    $1) return 0 ;;
    *) return 1 ;;
  esac
}

file_has_option() {
  fnmatch "*.$2.*" "$1"
}

task_find() {
  for task; do
    if [ "${task}" = - ]; then
      println "${STDIN_PATH}"
    else
      find_result="$(find "${task}" -type f -name '*.sh')" \
        || die "cannot find for the task path: '${task}'"
      [ -n "${find_result}" ] || die "there are no task files in the path: '${task_path}'"
      print "${find_result}" | LC_ALL=C sort || die
    fi
  done
}

# TODO: doc empty if already
search_library() {
  print "$1" | LC_ALL=C grep --quiet '^[0-9a-z-]\+$' \
    || die "bad library name: '$1'"

  hash_key="$(print "shef_library_hashC$1" | tr '/' 'S')" \
    || die 'cannot make hash key for the library'
  eval "hash_value=\"\${${hash_key}}\""

  if [ "${hash_value}" = found ]; then
    shef_library_path=
    return 0
  fi

  IFS=:
  for path in "${shef_include_path}"; do
    shef_library_path="${path}/$1.sh"
    if [ -f "${shef_library_path}" ]; then
      eval "${hash_key}=found"
      return 0
    fi
  done

  die "cannot find library: '$1'"
}

mktemp_task() {
  shef_task_file="$(mktemp --tmpdir shef.XXXXXXXXXX.sh)" \
    || die 'cannot create temp file for task script'
  trap "shred ${shef_task_file}; rm -f ${shef_task_file}" EXIT
}

write_task_line() {
    println "$1" >> "${shef_task_file}" || die 'cannot write to temp task file'
}

write_task() {
  while IFS= read -r line; do
    write_task_line "${line}"
    if [ "${all_inclusions_are_parses:-no}" = no ]; then
      case "${line#${line%%[![:blank:]]*}}" in
        \#.*)
          lib="$(print "${line}" \
            | sed 's/\(^[[:blank:]]*#\.[[:blank:]]*\|[[:blank:]]*$\)//g')" || die

          search_library "${lib}"
          if [ -n "${shef_library_path}" ]; then
            write_task "${shef_library_path}"
          fi
          all_inclusions_are_parses=no
        ;;
        \#*|'')
        ;;
        *)
          all_inclusions_are_parses=yes
        ;;
      esac
    fi
  done < "$1"
}

run_env() {
  case "$1" in
    local)
      cat < "${shef_task_file}" || die "${ERROR_TASK_RUN}"
      # sh < "${shef_task_file}" || die "${ERROR_TASK_RUN}"
    ;;
    target)
      [ -n "${SHEF_TARGET_HOST}" ] || die "${ERROR_VARIABLE_EMPTY}" SHEF_TARGET_HOST
      [ -n "${SHEF_TARGET_USER}" ] || die "${ERROR_VARIABLE_EMPTY}" SHEF_TARGET_USER

      cat < "${shef_task_file}" || die "${ERROR_TASK_RUN}"

      # ssh -T "${SHEF_TARGET_USER}@${SHEF_TARGET_HOST}" -- sh < "${shef_task_file}" \
      #   || die "${ERROR_TASK_RUN}"
    ;;
  esac

  shred "${shef_task_file}" || die 'cannot shred temp task file'
  > "${shef_task_file}" || die 'cannot truncate temp task file'
}

parse_env() {
  case "$1" in
    local|l) print local ;;
    target|t) print target ;;
    *) die --usage "cannot parse environment '$1'" ;;
  esac
}

cmd_version_print() {
  [ $# -eq 0 ] || die --usage "extra argument: '%s'" "$@"
  printf 'shef version %s\n' "${VERSION}"
}

cmd_shef() {
  options="$(getopt \
    --options I:e: \
    --longoptions include-path:,environment: \
    -- "$@")" || die --usage

  eval set -- "${options}"

  shef_include_path="${INCLUDE_PATH}"

  while :; do case "$1" in
    --include-path|-I)
      shef_include_path="$2:${shef_include_path}"
      shift 2
    ;;
    --environment|-e)
      shef_given_env="$(parse_env "$2")" || die
      shift 2
    ;;
    --)
      shift
      break
    ;;
  esac done

  files="$(task_find "${@:--}")" || die

  mktemp_task

  prev_env=
  while IFS= read -r file; do
    if [ -n "${shef_given_env}" ]; then
      env="${shef_given_env}"
    elif file_has_option "${file}" local; then
      ! file_has_option "${file}" target \
        || die "task cannot be 'local' and 'target' at same time: '${file}'"
      env=local
    elif file_has_option "${file}" target; then
      env=target
    else
      die "no environment specified for the task '${file}' and there are no given one"
    fi

    if [ "${env}" != "${prev_env}" -a -n "${prev_env}" ]; then
      run_env "${prev_env}"
    fi

    if [ -n "${prev_env}" ]; then
      write_task_line
    fi

    write_task "${file}"

    prev_env="${env}"
  done << EOF
${files}
EOF

  run_env "${env}"
}

case "$1" in
  --version|-V) shift; cmd_version_print "$@" ;;
  --help) usage_print ;;
  *) cmd_shef "$@" ;;
esac
