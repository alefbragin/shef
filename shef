#!/bin/sh

##
# Build info variables
##

PROGRAM=shef
VERSION=0.0.0

# Just amount of spaces that equals the length of the program's name.
# It's used for pretty print usage info.
PROGRAM_SPACES='   '


##
# Prelude functions and variables
##

NL='
'

print_usage() {
	cat <<- EOF || die "can't print usage"
		${1}Usage:
		  ${PROGRAM} --version | -V
		  ${PROGRAM} --help
		  ${PROGRAM} [--include-path=PATH[:PATH] | -I PATH[:PATH]]
		  ${PROGRAM_SPACES} [--remove-clashed-fifo | --no-remove-clashed-fifo]
		  ${PROGRAM_SPACES} [--] [<task>...]
	EOF
}

die() {
	if [ "$1" = --usage ]; then
		show_usage=1 && shift
	fi

	if [ $# -gt 0 ]; then
		format="$1" && shift
		printf "${PROGRAM}: ${format}\n" "$@" 1>&2 || exit 1
	fi

	if (( show_usage )); then
		print_usage "${NL}" 1>&2
	fi

	exit 1
}


##
# Environment variables
##

SHEF_STDIN_PATH="${SHEF_STDIN_PATH:-/dev/stdin}"
SHEF_RUNTIME_PATH="${SHEF_RUNTIME_PATH:-/run/user/$(id -u)/shef}" || die "can't gets a user ID"
SHEF_INCLUDE_PATH="${SHEF_INCLUDE_PATH:-/usr/local/lib/shef}"

SHEF_RUNNER="${SHEF_RUNNER:-sh}"
SHEF_LOCAL_SH_RUNNER="${SHEF_LOCAL_RUNNER:-sh}"
SHEF_REMOTE_SH_RUNNER="${SHEF_REMOTE_RUNNER:-ssh -T ${SHEF_REMOTE_USER}@${SHEF_REMOTE_HOST} -- sh}"


##
# Utility variables
##

ERROR_CLOSE_FD="can't close file descriptor: %s"


##
# Utility functions
##

# Executes a command and redirects argument to it's STDIN.
#
# Arguments:
#   $1    Redirected argument.
#   $2... Command with it's arguments.
#
# Outputs:
#   STDIN|STDOUT Command's output.
#
# Never dies.
rarg() {
	arg="$1" && shift
	"$@" <<- EOF
		${arg}
	EOF
}

check_sanity() {
	LC_ALL=C rarg "$3" grep --extended-regexp --quiet "$1" \
		|| die "$2: '%s'" "$3"
}


##
# Shef's implementation functions
##

find_task() {
	for task; do
		if [ "${task}" = - ]; then
			printf '%s\n' "${SHEF_STDIN_PATH}" || die "can't print STDIN path"
		else
			task_files="$(find "${task}" -type f -name '*.sh')" \
				|| die "can't find task files for the path: '${task}'"
			[ -n "${task_files}" ] || die "there are no task files in the path: '${task_path}'"
			LC_ALL=C rarg "${task_files}" sort || die "can't sort task files"
		fi
	done
}

# Search library by name and print it real path.
#
# If the library has already been found in a previous function call, the resulting
# real path will be empty. Note that found libraries are stored in the variable
# local to (sub)shell; this works as appropriate when this function is called
# in subshell associated with a runner.
#
# Arguments:
#   $1 Library name.
#
# Globals:
#   $shef_library_path Resulting real path or empty string.
#
# Dies if:
#   - bad library name;
#   - can't find library.
search_library() {
	check_sanity '^[0-9a-z/-]+$' 'bad library name' "$1"

	hash_key="$(rarg "shef_library_hashC$1" tr '/-' 'S_')" \
		|| die "can't make hash key for the library"
	eval "hash_value=\${${hash_key}}" \
		|| die "can't take value for the key: '${hash_key}'"

	if [ "${hash_value}" = found ]; then
		shef_library_path=
		return 0
	fi

	include_paths="${shef_include_path}"
	while [ -n "${include_paths}" ]; do
		case "${include_paths}" in
			*:*)
				prefix_path="${include_paths%%:*}"
				include_paths="${include_paths#*:}"
			;;
			*)
				prefix_path="${include_paths}"
				include_paths=
			;;
		esac
		prefix="${prefix_path%%=*}"
		shef_library_path="${prefix_path#${prefix}=}/${1#${prefix}}.sh"
		if [ -f "${shef_library_path}" ]; then
			eval "${hash_key}=found" \
				|| die "can't assign value for the key: '${hash_key}'"
			return 0
		fi
	done

	die "can't find library: '$1'"
}

include_libraries() {
	while IFS= read -r line; do
		printf '%s\n' "${line}" || die "can't print the line to the task"
		case "${line#${line%%[![:blank:]]*}}" in
			\#.*)
				lib="$(rarg "${line}" sed 's/\(^[[:blank:]]*#\.[[:blank:]]*\|[[:blank:]]*$\)//g')" \
					|| die "can't extract library name from line: '${line}'"

				search_library "${lib}"
				if [ -n "${shef_library_path}" ]; then
					include_libraries < "${shef_library_path}"
				fi
			;;
			\#*|'') continue ;;
			*) break ;;
		esac
	done
	cat
}

# Run task files by the runner.
#
# Arguments:
#   $1 Runner name. The name must be sanity.
#   $2 List of task files, each one on a separate line.
#
# Globals:
#   $SHEF_RUNTIME_PATH Path to create temporary FIFO.
#   $SHEF_*_RUNNER Command for substituted (instead of '*') runner.
#                  E.g. 'SHEF_LOCAL_RUNNER'.
#   $shef_remove_clashed_fifo If 'yes' remove file that clashed with temporary
#                             FIFO file name.
#   &3 Expect file descriptor to be assigned to STDIN.
#
# Dies if:
#   - no runner command setup for the runner name;
#   - subprocess for task preprocession fails;
#   - runner command error.
run() {
	runner_uppercase_name="$(rarg "$1" tr '[:lower:]' '[:upper:]')" \
		|| die "can't convert runner name to uppercase"

	eval "runner=\${SHEF_${runner_uppercase_name}_RUNNER}" \
		|| die "can't assign to the runner variable for: '$1'"
	[ -n "${runner}" ] || die "no runner command setup for this name: '$1'"

	if [ ! -d "${SHEF_RUNTIME_PATH}" ]; then
		mkdir --parent "${SHEF_RUNTIME_PATH}" \
			|| die "can't create runtime path: '${SHEF_RUNTIME_PATH}'"
	fi

	fifo="${SHEF_RUNTIME_PATH}/$$.$1.fifo"

	if [ "${shef_remove_clashed_fifo}" = yes ]; then
		rm -f "${fifo}" || die "can't remove clashed FIFO: '${fifo}'"
	fi

	mkfifo "${fifo}" || die "can't create temporary FIFO: '${fifo}'"
	exec 5<>"${fifo}" 6<"${fifo}" \
		|| die "can't open file descriptors for FIFO: '${fifo}'"
	rm "${fifo}" || die "can't remove clashed file: '${fifo}'"

	{
		while IFS= read -r run_file; do
			exec 4<&0 0<&3 || die "can't reassign file descriptors: 0, 3"
			include_libraries < "${run_file}"
			exec 0<&4 4<&- || die "can't reassign file descriptor 4 and close its"
		done <<- EOF >&5 || die "can't output tasks content to the pipe"
			$2
		EOF
	} &

	exec 5>&- || die "${ERROR_CLOSE_FD}" 5

	SHEF_RUNNER="$1" ${runner} <&6 || die "can't run task file with runner: '${runner}'"
	exec 6<&- || die "${ERROR_CLOSE_FD}" 6

	wait $! || die 'subprocess for task preprocession fails'
}

file_runner() {
	if [ "$1" = "${SHEF_STDIN_PATH}" ]; then
		[ -n "${shef_stdin_runner}" ] \
			|| die 'no runner specified for the task from STDIN'
		shef_runner="${shef_stdin_runner}"
	else
		shef_runner="${1%.sh}"
		shef_runner="${shef_runner##*[/.]}"
	fi

	check_runner_sanity "${shef_runner}"
}

check_included_path_sanity() {
	check_sanity '^[0-9a-z/-]*=[^:]+(:[0-9a-z/-]*=[^:]+)*$' \
		'incorrect format for included path with prefix' "$1"
}

check_runner_sanity() {
	check_sanity '^[0-9a-z-]+$' 'bad runner name' "$2"
}


##
# Commands
##

cmd_version() {
	[ $# -eq 0 ] || die --usage "extra argument: '%s'" "$@"
	echo "shef version ${VERSION}"
}

cmd() {
	options="$(getopt \
		--options I:r: \
		--longoptions include-path: \
		--longoptions remove-clashed-fifo,no-remove-clashed-fifo \
		-- "$@")" || die --usage

	eval set -- "${options}"

	check_included_path_sanity "${SHEF_INCLUDE_PATH}"
	shef_include_path="${SHEF_INCLUDE_PATH}"

	while :; do case "$1" in
		--include-path|-I)
			check_included_path_sanity "$2"
			shef_include_path="$2:${shef_include_path}" && shift 2
		;;
		# TODO: Remove this in flavor of environment variable
		--stdin-runner|-r)
			check_runner_sanity "$2"
			shef_stdin_runner="$2" && shift 2
		;;
		--remove-clashed-fifo)
			shef_remove_clashed_fifo=yes && shift
		;;
		--no-remove-clashed-fifo)
			shef_remove_clashed_fifo=no && shift
		;;
		--)
			shift && break
		;;
	esac done

	task_files="$(find_task "${@:--}")" || die

	exec 3<&0 || die "can't open file descriptor 3 for: 0"
	if IFS= read -r task_file; then
		file_runner "${task_file}"
		run_files="${task_file}"

		while IFS= read -r task_file; do
			prev_runner="${shef_runner}"
			file_runner "${task_file}"

			if [ "${prev_runner}" = "${shef_runner}" ]; then
				run_files="${run_files}${NL}${task_file}"
			else
				run "${prev_runner}" "${run_files}"
				run_files="${task_file}"
			fi
		done

		run "${shef_runner}" "${run_files}"
	fi <<- EOF || die "can't process task files"
		${task_files}
	EOF
	exec 3<&- || die "${ERROR_CLOSE_FD}" 3
}


##
# Entry point
##

case "$1" in
	--version|-V) shift; cmd_version "$@" ;;
	--help) print_usage ;;
	*) cmd "$@" ;;
esac
