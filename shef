#!/bin/sh

##
# Build info variables
##

PROGRAM=shef
VERSION=0.0.0


##
# Usage of environment variables
##

STDIN_PATH="${SHEF_STDIN_PATH:-/dev/stdin}"
INCLUDE_PATH="${SHEF_INCLUDE_PATH:-/usr/local/lib/shef}"

SH_RUNNER="${SHEF_SH_RUNNER:-sh}"
STDIN_RUNNER="${SHEF_STDIN_RUNNER:-${SH_RUNNER}}"
STDIN_EXTENSION="${SHEF_STDIN_EXTENSION:-sh}"

init_runtime_path() {
	RUNTIME_PATH="${SHEF_RUNTIME_PATH:-/run/user/$(id -u)/shef}" || die "can't gets a user ID"
}

REMOVE_CLASHED_FIFO="${SHEF_REMOVE_CLASHED_FIFO:-0}"


##
# Utility variables
##

NL='
'

USAGE="Usage:
	${PROGRAM} --version | -V
	${PROGRAM} --help
	${PROGRAM} [-I PATH[:PATH]] [--] [TASK...]"

ERROR_CLOSE_FD="can't close file descriptor: %s"


##
# Utility functions
##

printf_() {
	printf "$@" || { echo "can't use printf" 1>&2; exit 1; }
}

die() {
	if [ $# -gt 0 ]; then
		format="$1" && shift
		printf_ "${PROGRAM}: ${format}\n" "$@" 1>&2
	fi

	exit 1
}

die_usage() {
	if [ $# -gt 0 ]; then
		die "${1}${NL}${USAGE}" "$2"
	else
		die "${USAGE}"
	fi
}

# Executes a command and redirects argument to it's STDIN.
#
# Arguments:
#   $1    Redirected argument.
#   $2... Command with it's arguments.
#
# Outputs:
#   STDIN|STDOUT Command's output.
#
# Never dies.
rarg() {
	arg="$1" && shift
	"$@" <<- EOF
		${arg}
	EOF
}

check_sanity() {
	LC_ALL=C rarg "$3" grep --extended-regexp --quiet "$1" \
		|| die "$2: '%s'" "$3"
}


##
# Shef's implementation functions
##

find_tasks() {
	for find_tasks__path; do
		if [ "${find_tasks__path}" = - ]; then
			printf_ '%s\n' "${STDIN_PATH}"
		else
			find_tasks__files="$(find "${find_tasks__path}" -type f -name '*.*')" \
				|| die "failed while find task files in the path: %s" "${find_tasks__path}"
			[ -n "${find_tasks__files}" ] \
				|| die "there are no task files in the path: %s" "${find_tasks__path}"
			LC_ALL=C rarg "${find_tasks__files}" sort || die "can't sort task files"
		fi
	done
}

# Preprocess STDIN, make inclusions and remove comments.
#
# If the inclusion had already been included in this or a previous function call,
# it don't be included, and the inclusion directive will be removed.
# Note that information about inclusion that had already been included are stored in the variables
# local to (sub)shell; and the mechanism works as appropriate when this function is called
# in subshell associated with a current run.
#
# Arguments:
#   $1 Inclusions files extension.
#
# Globals:
#   $INCLUDE_PATH Inclusion searching path in $PATH format.
#
# Dies if:
#   - bad inclusion name;
#   - can't find inclusion;
#   - no files found in inclusion (when inclusion is a path);
#   - utilities errors occured.
preprocess() {
	while IFS= read -r preprocess__line; do case "${preprocess__line}" in
		\#.*)
			# Preprocess inclusion directive

			# Get inclusion name
			preprocess__inc_name="${preprocess__line#\#.}"
			# Left trim
			preprocess__inc_name="${preprocess__inc_name#${preprocess__inc_name%%[![:blank:]]*}}"
			# Right trim
			preprocess__inc_name="${preprocess__inc_name%${preprocess__inc_name##*[![:blank:]]}}"

			check_sanity '^[0-9a-z/-]+$' 'bad inclusion name' "${preprocess__inc_name}"

			preprocess__included_var_name="preprocess__$(
				rarg "${preprocess__inc_name}" tr '/-' 'S_'
			)_included" \
				|| die "can't make variable name for inclusion indicator"

			eval "preprocess__included=\${${preprocess__included_var_name}}"
			# Skip if already had been included
			if (( preprocess__included )); then
				continue
			fi

			# Search real path for the inclusion
			preprocess__inc_path=
			preprocess__paths="${INCLUDE_PATH}"
			while [ -n "${preprocess__paths}" ]; do
				preprocess__path="${preprocess__paths%%:*}"
				preprocess__inc_path="${preprocess__path}/${preprocess__inc_name}.$1"
				if [ -e "${preprocess__inc_path}" ]; then
					# Set an inclusion indicator for the inclusion
					eval "${preprocess__included_var_name}=1"
					break
				fi
				preprocess__paths="${preprocess__paths#${preprocess__path}}"
				preprocess__paths="${preprocess__paths#:}"
			done

			[ -n "${preprocess__inc_path}" ] \
				|| die "can't find inclusion: %s" "${preprocess__inc_name}"

			if [ ! -d "${preprocess__inc_path}" ]; then
				# Include the file and all it's inclusions
				preprocess "$1" < "${preprocess__inc_path}"
			else

				# Recursively include all file (and it's inclusions)
				# with appropriate extension from directory

				preprocess__inc_files="$(find "${preprocess__inc_path}" -type f -name "*.$1")" \
					|| die "failed while find files in directory for inclusion: %s" \
						"${preprocess__inc_path}"

				[ -n "${preprocess__inc_files}" ] \
					|| die "there are no task files in the inclusion path: %s" \
						"${preprocess__inc_path}"

				while IFS= read -r preprocess__inc_file; do
					# exec 7<&0 0<&3 || die "can't reassign file descriptors: 0, 7"
					preprocess "$1" < "${preprocess__inc_file}"
					# exec 0<&7 7<&- || die "can't reassign file descriptor and close it: 0, 7"
				done <<- EOF || die "can't preprocess inclusion files"
					${preprocess__inc_files}
				EOF

			fi
		;;
		\#*)
			# Skip comments that starts right from the line begining.
			# We do not remove comments are padded with spaces to keep it's in heredocs.
			continue
		;;
		*) printf_ '%s\n' "${preprocess__line}" ;;  # Print ordinary line w/o modification
	esac done
}

# Run task files by the runner command.
#
# Arguments:
#   $1 Runner command.
#   $2 List of task files, each one on a separate line.
#
# Globals:
#   $RUNTIME_PATH        Path to create temporary FIFO.
#   $REMOVE_CLASHED_FIFO If trueish, remove file that clashed with temporary FIFO file name.
#   &3                   File descriptor. Expect to be assigned to STDIN.
#
# Dies if:
#   - can't create runtime path;
#   - can't create, open, remove FIFO;
#   - can't reassign, close file descriptors;
#   - task preprocessing fails;
#   - runner command error occured.
run() {
	if [ ! -d "${RUNTIME_PATH}" ]; then
		mkdir --parent "${RUNTIME_PATH}" \
			|| die "can't create runtime path: '${RUNTIME_PATH}'"
	fi

	run__fifo="${RUNTIME_PATH}/$$.fifo"

	if (( REMOVE_CLASHED_FIFO )); then
		rm -f "${run__fifo}" || die "can't remove clashed FIFO: %s" "${run__fifo}"
	fi

	mkfifo "${run__fifo}" || die "can't create temporary FIFO: %s" "${run__fifo}"
	exec 5<>"${run__fifo}" 6<"${run__fifo}" \
		|| die "can't open file descriptors for FIFO: %s" "${run__fifo}"
	rm "${run__fifo}" || die "can't remove FIFO file: %s" "${run__fifo}"

	{
		while IFS= read -r run__file; do
			exec 4<&0 0<&3 || die "can't reassign file descriptors: 0, 3"

			# Sanity check of dot presence in file name isn't needed
			# becouse of '*.*' pattern in the find command in find_tasks function.
			preprocess "${run__file##*.}" < "${run__file}"

			exec 0<&4 4<&- || die "can't reassign file descriptor and close it: 0, 4"
		done <<- EOF >&5 || die "can't output tasks content to the pipe"
			$2
		EOF
	} &

	exec 5>&- || die "${ERROR_CLOSE_FD}" 5

	$1 <&6 || die "can't run task file with runner"
	exec 6<&- || die "${ERROR_CLOSE_FD}" 6

	wait $! || die 'subprocess for task preprocessing fails'
}

set_file_runner() {
	if [ "$1" = "${STDIN_PATH}" ]; then
		[ -n "${STDIN_RUNNER}" ] \
			|| die 'no runner specified for the task from STDIN'
		FILE_RUNNER="${STDIN_RUNNER}"
	else
		set_file_runner__name="${1##*/}"
		set_file_runner__name="$(
			rarg "${set_file_runner__name#*.}" tr '.[:lower:]' '_[:upper:]'
		)" || die "can't process file's suffix"

		check_sanity '^[0-9a-z]+$' 'bad runner name' "${set_file_runner__name}"

		set_file_runner__env_name="SHEF_${set_file_runner__name}_RUNNER"

		eval "FILE_RUNNER=\${${set_file_runner__env_name}}" \
			|| die "can't assign FILE_RUNNER variable from: '${set_file_runner__env_name}'"

		[ -n "${FILE_RUNNER}" ] \
			|| die "no runner specified for the task: %s in %s" "$1" "${set_file_runner__env_name}"
	fi
}


##
# Commands
##

cmd_version() {
	[ $# -eq 0 ] || die_usage "extra argument: '%s'" "$1"
	echo "shef version ${VERSION}"
}

cmd_help() {
	echo "${USAGE}"
}

cmd() {
	while getopts ':I:' cmd__option; do case "${cmd__option}" in
		I)
			check_sanity '^[^:]+(:[^:]+)*$' 'incorrect include paths format' "${OPTARG}"
			INCLUDE_PATH="${OPTARG}:${INCLUDE_PATH}"
		;;
		\?) die_usage 'invalid option: -%s' "${OPTARG}" ;;
		:) die_usage 'option -%s requires an argument' "${OPTARG}" ;;
	esac done
	shift $(( OPTIND-1 ))

	cmd__task_files="$(find_task "${@:--}")" || die

	init_runtime_path

	exec 3<&0 || die "can't open file descriptor 3 for: 0"
	if IFS= read -r cmd__task_file; then
		set_file_runner "${cmd__task_file}"
		cmd__files_bunch="${cmd__task_file}"

		while IFS= read -r cmd__task_file; do
			cmd__prev_file_runner="${FILE_RUNNER}"
			set_file_runner "${cmd__task_file}"

			if [ "${cmd__prev_file_runner}" = "${FILE_RUNNER}" ]; then
				cmd__files_bunch="${cmd__files_bunch}${NL}${cmd__task_file}"
			else
				run "${cmd__prev_file_runner}" "${cmd__files_bunch}"
				cmd__files_bunch="${cmd__task_file}"
			fi
		done

		run "${FILE_RUNNER}" "${cmd__files_bunch}"
	fi <<- EOF || die "can't process task files"
		${cmd__task_files}
	EOF
	exec 3<&- || die "${ERROR_CLOSE_FD}" 3
}


##
# Entry point
##

case "$1" in
	--version|-V) shift; cmd_version "$@" ;;
	--help) cmd_help ;;
	*) cmd "$@" ;;
esac
